#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bitcloud.h"

#include "nodepool_sql.h"

sqlite3 *nodepool;

/*
 Opens the nodepool db.
 If it doesn't exist, it creates all the necessary tables.
*/

BCError bc_open_nodepool (const char* filename)
{
  int rc;
  char *err;

  rc = sqlite3_open_v2(filename, &nodepool, SQLITE_OPEN_READWRITE, NULL);
  if (rc) { /* file doesn't exist yet or is readonly */
    sqlite3_close (nodepool);
    rc = sqlite3_open(filename, &nodepool);
    if (rc) {
      sqlite3_close (nodepool);
      nodepool = NULL;
      bc_log(BC_DB_ERROR,
             "could not create the db: %s",
             sqlite3_errmsg(nodepool));
      return (BC_DB_ERROR);
    }
    /* Create all the tables in the nodepool.sql file. nodepool_sql.h was
       generated by xxd utility in the Makefile to include the SQL source into
       the executable. */
    nodepool_sql[nodepool_sql_len] = 0; /* <-- because xxd doesn't end the
                                           string in NULL. Look Makefile. */
    rc = sqlite3_exec (nodepool, (const char*)nodepool_sql,NULL,NULL, &err);
    if (rc != SQLITE_OK) {
      sqlite3_free (err);
      sqlite3_close (nodepool);
      remove (filename);
      nodepool = NULL;
      bc_log (BC_DB_ERROR, "%s", err);
      return (BC_DB_ERROR);
    }
    bc_log (BC_OK, "Nodepool created");
  }

  return BC_OK;
}



/* general authorization callback function for sqlite */

BCError bc_auth (void *user_data,
                 int event_code,
                 const char *event_spec,
                 const char *event_spec2,
                 const char *db_name,
                 const char *trigger)
{
  switch (event_code) {
    default:
      return SQLITE_DENY;
    }
  return SQLITE_DENY;
}

BCBool log_to_stdout = 1;

void bc_log (BCError error, const char *msg, ...)
{
  va_list args;
  char buffer[BC_MAX_LOG_SIZE];

  va_start(args, msg);
  vsnprintf (buffer, BC_MAX_LOG_SIZE, msg, args);
  va_end(args);

  if (log_to_stdout) {
    if (error!=BC_OK) printf ("ERROR %d: ", error);
    printf ("%s\n", buffer);
  }

  /* log into the nodepool: */
  if (nodepool) {
    /* static variables and prepared statements to make it faster:*/
    static sqlite3_stmt *stmt;
    static char *sql = "INSERT INTO logs(error_code,log) VALUES(?,?)";
    static const char *tail;
    static int rc = -1;

    if (rc==-1) {
      rc = sqlite3_prepare(nodepool, sql, strlen(sql), &stmt, &tail);

      if (rc!=SQLITE_OK) {
        fprintf (stderr, "FATAL: error in the database, cannot log.\n");
        sqlite3_close (nodepool);
        exit(rc);
      }
    }

    sqlite3_bind_int(stmt, 1, error);
    sqlite3_bind_text(stmt, 2, buffer, -1, SQLITE_STATIC);

    sqlite3_step(stmt);

    int reset_err = sqlite3_reset(stmt);
    if (reset_err) {
      fprintf (stderr,
               "FATAL: database error (SQLite error %d).\n",
               reset_err);
      exit(BC_DB_ERROR);
    }
  }
}


sqlite3_stmt* bc_prepare_sql (const char *sql)
{
  sqlite3_stmt *stmt;
  int rc = sqlite3_prepare(nodepool, sql, strlen(sql), &stmt, NULL);
  if (rc!=SQLITE_OK) {
    bc_log (BC_BAD_SQL, (const char*) sqlite3_errmsg(nodepool));
    return NULL;
  }
  return stmt;
}

BCError bc_sql (sqlite3_stmt **stmt, const char* sql, char *format, ...)
{
  va_list args;
  int pos = 1;

  if (!*stmt) {/* if NULL, create a new statement */
    if (!sql) return BC_BAD_SQL;
    else *stmt = bc_prepare_sql (sql);
  }
  if (!*stmt) return BC_BAD_SQL;

  va_start (args, format);

  for (pos=1; *format != 0; pos++, format++) {
    switch (*format) {
    case 'l':
      sqlite3_bind_int(*stmt, pos, va_arg(args, int));
      continue;
    case 'S':
      sqlite3_bind_text (*stmt, pos, va_arg(args, char*), -1, SQLITE_STATIC);
      continue;
    case 'D':
      sqlite3_bind_double(*stmt, pos, va_arg(args, double));
      continue;
    case 'B':
      /* TODO: BLOB CASE */
      continue;
    default:
      bc_log (BC_BAD_SQL, "Incorrect bind format '%s'", format);
      return BC_BAD_SQL;
    }
  }
  sqlite3_step (*stmt);
  va_end (args);
  return BC_OK;
}


BCError bc_get_row (sqlite3_stmt *stmt, char *format, ...)
{
  va_list args;
  int pos = 1;
  BCError err;
  char **text;

  /* internal function to check that sqlite3 doesn't complain: */
  BCError check_errors (void) {
    int errcode;
    errcode = sqlite3_errcode (nodepool);
    if ((errcode!=SQLITE_OK) && (errcode!=SQLITE_ROW)) {
      bc_log (BC_BAD_SQL,
              "error getting a column in a record: %s",
              sqlite3_errmsg(nodepool));
      return BC_BAD_SQL;
    }
    return BC_OK;
  }

  if (!stmt) return BC_BAD_SQL;

  va_start (args, format);

  for (pos=0; *format != 0; pos++, format++) {
    switch (*format) {
    case 'l':
      *va_arg (args, int*) = sqlite3_column_int(stmt, pos);
      if ((err = check_errors ()) != BC_OK) return err;
      continue;
    case 'S':
      text = va_arg (args, char**);
      *text = (char*) sqlite3_column_text(stmt, pos);
      if ((err = (check_errors ())) != BC_OK) {
        *text = NULL; /* avoid further buffer overrun */
        return err;
      }
      /* copy the string because sqlite3 deletes the string automatically: */
      *text = strdup ((const char *)*text);
      continue;
    case 'D':
      *va_arg (args, double*) = sqlite3_column_double(stmt, pos);
      if ((err = check_errors ()) != BC_OK) return err;
      continue;
    case 'B':
      /* TODO: BLOBS */
      if ((err = check_errors ()) != BC_OK) return err;
      continue;
    default:
      sqlite3_reset (stmt);
      bc_log (BC_BAD_SQL, "Incorrect bind variables format '%s'", format);
      return BC_BAD_SQL;
    }
  }
  va_end (args);
  /* if there are more rows available, return BC_NEXT_ROW, so the program
     can continue to extract rows, otherwise return BC_OK which means there
     are no more rows, and finalize the statement */
  if (sqlite3_step (stmt) == SQLITE_ROW) return BC_NEXT_ROW;
  else {
    sqlite3_reset (stmt);
    return BC_OK;
  }
}

#define bc_stmt_reset sqlite3_reset

char *bc_get_table_name (int table_id) {

  char *name;
  static sqlite3_stmt *stmt = NULL;

  if (bc_sql (&stmt,
              "SELECT table_name FROM table_rules WHERE table_id=?",
              "l", table_id)
      || bc_get_row (stmt, "S", &name))
    return NULL;

  return name;
}

BCError bc_deserialize (int table_id, void *record, ...)
{
  /* TODO */
  return BC_OK;
}
